package uk.ac.ed.inf;

import java.util.ArrayList;

/**
 * This class provide all the algorithm to find the route.
 */
public class FindPath {

    private static final double[] angles = {0,22.5,45,67.5,90,112.5,135,157.5,180,202.5,225,247.5,270,292.5,315,337.5};
    private static final double MOVE_DISTANCE = 0.00015;

    /**
     * The algorithm simply generate the direct flight path from the start to the end without checking the no-fly zones.
     * Since we can only fly by given directions, so the drone will fly with the closest direction to the angle between two point and
     * move horizontally or vertically to the end when it's close to it.
     * @param start The start point of the flight path
     * @param end The end point of the flight path
     * @return The direct path points by points from the start to the end
     */
    private static ArrayList<LngLat> generateDirectFlightpath(LngLat start, LngLat end){
        ArrayList<LngLat> directFlightpath = new ArrayList<>();
        double direction = start.closedAngle(end);
        LngLat move = start;
        boolean turn = false;
        while (true){
            move = move.nextPosition(direction);
            directFlightpath.add(move);
            if (!(turn)) {
                if (direction == 90.0 || direction == 270){
                    if (Math.abs(move.lat() - end.lat()) <= MOVE_DISTANCE) {
                        if (move.lng() < end.lng()) {
                            direction = 0;
                            turn = true;
                        } else {
                            direction = 180;
                            turn = true;
                        }
                    }
                }else {
                    if (Math.abs(move.lng() - end.lng()) <= MOVE_DISTANCE) {
                        if (move.lat() < end.lat()) {
                            direction = 90.0;
                            turn = true;
                        } else {
                            direction = 270;
                            turn = true;
                        }
                    }
                }
            }else {
                if (move.closeTo(end)) {
                    break;
                }
            }
        }
        return directFlightpath;
    }

    /**
     * This method can get all the parts from the direct path that is in the no-fly zone and use the algorithm to avoid the no-fly zones and generate the perfect route.
     * @param start the start point of the flight.
     * @param end the end point of the flight.
     * @return the best route generated by the algorithm.
     */
    public static ArrayList<LngLat> generateGoodFlightpath(LngLat start, LngLat end){
        ArrayList<LngLat> directFlightPath = generateDirectFlightpath(start , end);
        ArrayList<LngLat> goodFlightPath = new ArrayList<>();
        boolean stepInNoFlyZone = false;
        ArrayList<LngLat[]> inNoneFlyZonePoints = new ArrayList<>();
        LngLat startPoint = null;
        ArrayList<ArrayList<LngLat>> savedPaths = new ArrayList<>();
        ArrayList<LngLat> pathNotInNFZ = new ArrayList<>();
        boolean store = false;
        for (LngLat point : directFlightPath){
            if (!(stepInNoFlyZone)){
                if (point.inNoFlyZone()){
                    stepInNoFlyZone = true;
                    startPoint = pathNotInNFZ.get(pathNotInNFZ.size() - 1);
                    savedPaths.add(pathNotInNFZ);
                    pathNotInNFZ = new ArrayList<>();
                }else{
                    pathNotInNFZ.add(point);
                    if (store){
                        inNoneFlyZonePoints.add(new LngLat[]{startPoint, point});
                        store = false;
                    }
                }
            }else {
                if (!(point.inNoFlyZone())){
                    stepInNoFlyZone = false;
                    store = true;
                }
            }
        }
        savedPaths.add(pathNotInNFZ);
        for (int i = 0; i < savedPaths.size() - 1; i ++){
            goodFlightPath.addAll(savedPaths.get(i));
            goodFlightPath.addAll(avoidNoFlyZone(inNoneFlyZonePoints.get(i)[0],inNoneFlyZonePoints.get(i)[1]));
        }
        goodFlightPath.addAll(savedPaths.get(savedPaths.size() - 1));
        return goodFlightPath;
    }

    /**
     * This function is used to support the algorithm, this will provide the directions that the drones can go which from the best direction with
     * the increment represent the clockwise or anti-clockwise.
     * @param angle the best direction between two points
     * @param increment this can only be two integers, +1 means the directions are generated anti-clockwise, -1 means the directions are generated clockwise.
     * @return the directions generated from the best direction.
     */
    private static ArrayList<Double> generateNextDirections(double angle , int increment){
        ArrayList<Double> nextDirections = new ArrayList<>();
        int directionIndex = 0;
        int firstIndex;
        int secondIndex;
        for (double direction : angles){
            if (angle == direction){
                break;
            }
            directionIndex ++;
        }
        firstIndex = directionIndex - increment;
        //secondIndex = directionIndex;
        for (int i = 0; i < 15;i++){
            if (firstIndex + increment > 15){
                firstIndex = 0;
            }if(firstIndex + increment < 0){
                firstIndex = 15;
            }else{
                firstIndex += increment;
            }
            nextDirections.add(angles[firstIndex]);
        }
        return nextDirections;
    }

    /**
     * This method use the algorithm to avoid the no-fly zones, which gives the start and end point that need to avoid the
     * no-fly zone and use clockwise and anti-clockwise way to find two route that surround the edge of the no-fly zone and return the shortest route.
     * @param start The point that almost run into the no- fly zone.
     * @param end The point that is just fly out the no-fly zone.
     * @return The best route that surround the no-fly zone.
     */
    private static ArrayList<LngLat> avoidNoFlyZone(LngLat start , LngLat end){
        ArrayList<LngLat> avoidPath = new ArrayList<>();
        LngLat move;
        ArrayList<Double> nextDirections;
        int timer;
        LngLat previousPoint;
        LngLat nextPosition;
        double closedAngle;
        ArrayList<LngLat> clockwiseRoute = new ArrayList<>();
        ArrayList<LngLat> antiClockwiseRouse = new ArrayList<>();
        boolean enteredCentralArea = start.inCentralArea();
        boolean centralAreaCheck = true;
        for (int increment : new int[]{-1,1}) {
            timer = 0;
            move = start;
            previousPoint = end;
            while (timer < 300) {
                if (move.closeTo(end)) {
                    break;
                }
                closedAngle = move.closedAngle(end);
                nextDirections = generateNextDirections(closedAngle,increment);
                for (double direction : nextDirections) {
                    nextPosition = move.nextPosition(direction);
                    if (enteredCentralArea) {
                        centralAreaCheck = nextPosition.inCentralArea();
                    }else{
                        if (nextPosition.inCentralArea()){
                            enteredCentralArea = true;
                        }
                    }
                    if ((!(nextPosition.inNoFlyZone())) && centralAreaCheck) {
                        if ((nextPosition.lat() != previousPoint.lat()) && (nextPosition.lng() != previousPoint.lng())) {
                            previousPoint = move;
                            move = nextPosition;
                            break;
                        }
                    }
                }
                if (increment == -1){
                    clockwiseRoute.add(move);
                }else {
                    antiClockwiseRouse.add(move);
                }
                timer++;
            }
        }
        if (clockwiseRoute.size() < antiClockwiseRouse.size()){
            avoidPath.addAll(clockwiseRoute);
        }else {
            avoidPath.addAll(antiClockwiseRouse);
        }
        return avoidPath;
    }
}
